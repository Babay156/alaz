To clean debug print pipe -> cat /sys/kernel/debug/tracing/trace_pipe

When debugging, bpf_trace_printk's "fmt_size" is important. Otherwise, you can get errors like below from verifier:
    load program: permission denied: invalid access to map value, value_size=31 off=14 size=20: R1 min value is outside of the allowed memory range (228 line(s) omitted)


 // const char *msg = "established";
      // bpf_trace_printk(msg, 12);

To see bpf calls with strace: 
    sudo strace -o calls.txt  -f -e trace=bpf,ioctl go run -exec sudo main.go bpf_bpfel.go

See "/sys/kernel/debug/tracing/events" to find available tracepoints

> cat /sys/kernel/debug/tracing/events/sock/inet_sock_set_state/format

To generate kernel headers files necessary:
    > bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

See a tracepoints format:
    > cat /sys/kernel/debug/tracing/events/task/task_newtask/format

> Printing examples:
    // const char *msg = "Pid -> **%d**"; // 12 + specifier (2)
    // bpf_trace_printk(msg, 14, pid);

    // const char *msg2 = "Source Port: %d\n";
    // bpf_trace_printk(msg2, 17, args.sport);

    // const char *msg3 = "SAddr: %d\n";
    // bpf_trace_printk(msg3, 11, e.saddr[0]);
    // bpf_trace_printk(msg3, 11, e.saddr[1]);
    // bpf_trace_printk(msg3, 11, e.saddr[2]);
    // bpf_trace_printk(msg3, 11, e.saddr[3]);
    // bpf_trace_printk(msg3, 11, e.saddr[4]);

// To debug program in vscode:
    - First build the program with "go build -o myapp main.go bpf_bpfel.go"
    -  "mode": "exec",
        "program": "${workspaceFolder}/prog/tcp_state/myapp",
        "console": "integratedTerminal",
        "asRoot": true,

// To get first 50 lines of logs from a pod: 
> kubectl logs -n ddosify alaz-daemonset-jvkcn | head -n 50

// Build and push to amazon docker hub:
docker build -t alaz:test1 .
docker tag alaz:test1 158138719754.dkr.ecr.eu-central-2.amazonaws.com/alaz:test1
docker push 158138719754.dkr.ecr.eu-central-2.amazonaws.com/alaz:test1


// Compile bpf.c files with clang and llvm
// TODO: create our own ebpf-builder image
> clang \
    -target bpf \
        -D __TARGET_ARCH_x86 \
    -Wall \
    -O2 -g -o hello-buffer-config.bpf.o -c kprobe.c
> llvm-strip -g hello-buffer-config.bpf.o (strip executable from debugging symbols)


BPF_CLANG=clang-14 BPF_CFLAGS="-O2 -g -Wall -Werror -D__TARGET_ARCH_x86"  go generate ./...

// To see available tracepoints:
> cat /sys/kernel/tracing/available_events (SEC definition bunlarla match ediyor)

// How to take arguments of a function attached to a tracepoint:
 1) Look at the format from :
    > cat /sys/kernel/debug/tracing/events/sock/inet_sock_set_state/format
    or
    > use bcc's tplife tool: 
        > sudo tplist-bpfcc -v | grep inet_sock_set_state -A 20
 2) search corresponding struct in vmlinux.h file, if exists copy into your headers
    If not, create your own struct, be careful with paddings

cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_connect/format

// Look for syscall:
> man 2 connect
    int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);

// Look format of the tracepoint:
> cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_connect/format
    name: sys_enter_connect
ID: 1473
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int fd;   offset:16;      size:8; signed:0;
        field:struct sockaddr * uservaddr;      offset:24;      size:8; signed:0;
        field:int addrlen;      offset:32;      size:8; signed:0;

print fmt: "fd: 0x%08lx, uservaddr: 0x%08lx, addrlen: 0x%08lx", ((unsigned long)(REC->fd)), ((unsigned long)(REC->uservaddr)), ((unsigned long)(REC->addrlen))
args should be the same as in the format


Address Families : AF_INET, AF_INET6, AF_PACKET, AF_UNIX, AF_XDP
Protocol Families : PF_INET, PF_INET6, PF_PACKET, PF_UNIX, PF_XDP
Transport Protocols : IPPROTO_UDP or IPPROTO_TCP
Sock Types : SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW.


docker run --name postgres-alaz -e POSTGRES_USER=alazuser -e POSTGRES_PASSWORD=alazpwd -e POSTGRES_DB=alazdb -p 5432:5432 -d postgres:13.6

CGO_ENABLED=0 K8S_COLLECTOR_ENABLED=true IN_CLUSTER=false POSTGRES_HOST=localhost POSTGRES_PORT=5432 POSTGRES_USER=alazuser POSTGRES_PASSWORD=alazpwd POSTGRES_DB=alazdb go run main.go


Detaching bpf programs with bpftool
> bpftool perf list
then 
> kill -9


bpftool map dump ile human readable formatta gorebilmek icin
__type(key, void *);
__type(value, struct sk_info);

seklinde tanimlaman lazim map icin
// sk_info icinde pointer olursa  executing "common" at <$.TypeDeclaration>: error calling TypeDeclaration: Struct:"rw_args_t": field 1: type *btf.Pointer: not supported 
--> uint ile yazcan



// Ebpf error: 
https://github.com/cilium/ebpf/blob/master/btf/core.go  0xbad2310
invalid func unknown#195896080: 
195896080 -> 0xbad2310

"bad relo"

it means libbpf couldn't relocate a struct field reference against the current running kernel's layout
basically, your vmlinux.h defines a struct field that wasn't defined when your kernel was built

yani kerneldaki struct fieldina erismiyorsun. kendin tanimlamissin ama kernelde yok. bunu core_read yapmaya
calisirsan kernelda bulamadigi icin mapping de yapamiyor error veriyor.

core -> kernel structurelarina erisirken 
kendi 